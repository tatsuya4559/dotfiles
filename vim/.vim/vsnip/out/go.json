{"enum":{"description":"enum","body":["type $1 int","const (","\t$3 $1 = iota","\t$4",")"],"prefix":"enum"},"pwd":{"description":"pwd","body":["cwd, err := os.Getwd()"],"prefix":"pwd"},"fnopt":{"description":"functional option pattern","body":["type Option func(*$1)","","func WithX(x string) Option {","\treturn func(f *$1) {","\t\tf.x = x","\t}","}","","func New$1(options ...Option) {","\t$2 := $1{}","\tfor _, opt := range options {","\t\topt(&$2)","\t}","\treturn &$2","}"],"prefix":"fnopt"},"run":{"description":"run command","body":["cmd := exec.Command(${1:\"ls\", \"-l\"})","err := cmd.Run()"],"prefix":"run"},"fors":{"description":"for select","body":["for {","\tselect {","\tcase $1:","\t}","}"],"prefix":"fors"},"rmr":{"description":"rm -r","body":["err := os.RemoveAll($1)"],"prefix":"rmr"},"fuzz":{"description":"fuzzing test","body":["func Fuzz$1(f *testing.F) {","\tf.Add($2)","\tf.Fuzz(func(t *testing.T, $3) {","\t\t$4","\t})","}"],"prefix":"fuzz"},"exists":{"description":"check file or dir exists","body":["if _, err := os.Stat($1); os.IsNotExist(err) {","\t$2","}"],"prefix":"exists"},"glob":{"description":"glob","body":["files, err := filepath.Glob(\"$1\")"],"prefix":"glob"},"ut":{"description":"unit test","body":["func Test$1(t *testing.T) {","\t$2","}"],"prefix":"ut"},"mkdir":{"description":"mkdir","body":["err := os.Mkdir($1, os.ModePerm)"],"prefix":"mkdir"},"recover":{"description":"recover","body":["defer func() {","\tif r := recover(); r != nil {","\t\t$1","\t}","}()"],"prefix":"recover"},"pack":{"description":"package","body":["package ${TM_DIRECTORY}"],"prefix":"pack"},"ife":{"description":"if error","body":["if err != nil {","\t${1:return nil, err}","}"],"prefix":"ife"},"utt":{"description":"table driven test skelton","body":["func Test$1(t *testing.T) {","\ttests := map[string]struct {","\t\tinput string","\t\twant string","\t}{","\t\t\"Summary\": {","\t\t  input: \"\",","\t\t  want: \"\",","\t\t},","\t}","","\tfor summary, tt := range tests {","\t\tt.Run(summary, func(t *testing.T) {","\t\t\tgot := FUT(tt.input)","\t\t\tif got != tt.want {","\t\t\t\tt.Errorf(\"want %v, but got %v\", tt.want, got)","\t\t\t}","\t\t})","\t}","}"],"prefix":"utt"},"rm":{"description":"rm","body":["err := os.Remove($1)"],"prefix":"rm"},"file.open":{"description":"open file","body":["f, err := os.Open($1)","if err != nil {","\treturn err","}","defer f.Close()"],"prefix":"file.open"},"mkdirp":{"description":"mkdir -p","body":["err := os.MkdirAll($1, os.ModePerm)"],"prefix":"mkdirp"},"fn":{"description":"function","body":["func $1 {","}"],"prefix":"fn"},"main":{"description":"main function","body":["package main","","func main() {","\t$1","}"],"prefix":"main"},"hf":{"description":"http handler func","body":["func ${1:handler}(w http.ResponseWriter, r *http.Request) {","\t$2","}"],"prefix":"hf"},"bench":{"description":"benchmark","body":["func Benchmark$1(b *testing.B) {","\tb.ResetTimer()","\tfor i := 0; i < b.N; i++ {","\t\t$2","\t}","}"],"prefix":"bench"},"file.create":{"description":"create file","body":["f, err := os.Create($1)","if err != nil {","\treturn err","}","defer f.Close()"],"prefix":"file.create"},"cd":{"description":"cd","body":["err := os.Chdir($1)"],"prefix":"cd"},"export":{"description":"export","body":["err := os.Setenv($1, $2)"],"prefix":"export"},"mv":{"description":"mv","body":["err := os.Rename($1, $2)"],"prefix":"mv"},"env":{"description":"env var","body":["$1 := os.Getenv($2)"],"prefix":"env"},"append":{"description":"append to slice","body":["$1 = append($1, $2)"],"prefix":"append"}}
