{"enum":{"description":"enum","body":["type $1 int","const (","\t$3 $1 = iota","\t$4",")"],"prefix":"enum"},"pwd":{"description":"pwd","body":["cwd, err := os.Getwd()"],"prefix":"pwd"},"fori":{"description":"for loop","body":["for i:=${1:0}; i<${2:n}; ${3:i++} {","\t$4","}"],"prefix":"fori"},"mv":{"description":"mv","body":["err := os.Rename($1, $2)"],"prefix":"mv"},"tfatal":{"description":"t.Fatalf","body":["t.Fatalf(\"want %v, but got %v\", $1, $2)"],"prefix":"tfatal"},"run":{"description":"run command","body":["cmd := exec.Command(${1:\"ls\", \"-l\"})","err := cmd.Run()"],"prefix":"run"},"main":{"description":"main function","body":["package main","","func main() {","\t$1","}"],"prefix":"main"},"fors":{"description":"for select","body":["for {","\tselect {","\tcase $1:","\t}","}"],"prefix":"fors"},"st":{"description":"struct","body":["type $1 struct {","\t$2","}"],"prefix":"st"},"rmr":{"description":"rm -r","body":["err := os.RemoveAll($1)"],"prefix":"rmr"},"fuzz":{"description":"fuzzing test","body":["func Fuzz$1(f *testing.F) {","\tf.Add($2)","\tf.Fuzz(func(t *testing.T, $3) {","\t\t$4","\t})","}"],"prefix":"fuzz"},"exists":{"description":"check file or dir exists","body":["if _, err := os.Stat($1); os.IsNotExist(err) {","\t$2","}"],"prefix":"exists"},"glob":{"description":"glob","body":["files, err := filepath.Glob(\"$1\")"],"prefix":"glob"},"ut":{"description":"unit test","body":["func Test$1(t *testing.T) {","\t$2","}"],"prefix":"ut"},"utm":{"description":"table driven test skelton(map ver.)","body":["func Test$1(t *testing.T) {","\tt.Parallel()","","\ttests := map[string]struct {","\t\tinput string","\t\twant string","\t}{","\t\t\"name\": {\"hoge\", \"fuga\"},","\t}","","\tfor name, tt := range tests {","\t\tt.Run(fmt.Sprintf(name), func(t *testing.T) {","\t\t\tt.Parallel()","\t\t\tgot := Testee(tt.input)","\t\t\tif got != tt.want {","\t\t\t\tt.Errorf(\"want %v, but got %v\", tt.want, got)","\t\t\t}","\t\t})","\t}","}"],"prefix":"utm"},"mkdir":{"description":"mkdir","body":["err := os.Mkdir($1, os.ModePerm)"],"prefix":"mkdir"},"fnopt":{"description":"functional option pattern","body":["type Option func(*$1)","","func WithX(x string) Option {","\treturn func(f *$1) {","\t\tf.x = x","\t}","}","","func New$1(options ...Option) {","\t$2 := $1{}","\tfor _, opt := range options {","\t\topt(&$2)","\t}","\treturn &$2","}"],"prefix":"fnopt"},"recover":{"description":"recover","body":["defer func() {","\tif r := recover(); r != nil {","\t\t$1","\t}","}()"],"prefix":"recover"},"pack":{"description":"package","body":["package ${TM_DIRECTORY}"],"prefix":"pack"},"ife":{"description":"if error","body":["if err != nil {","\t${1:return nil, err}","}"],"prefix":"ife"},"utt":{"description":"table driven test skelton","body":["func Test$1(t *testing.T) {","\ttests := []struct {","\t\tinput string","\t\twant string","\t}{","\t\t{\"hoge\", \"fuga\"},","\t}","","\tfor _, tt := range tests {","\t\tt.Run(fmt.Sprintf(\"%s\", tt.input), func(t *testing.T) {","\t\t\tgot := Testee(tt.input)","\t\t\tif got != tt.want {","\t\t\t\tt.Errorf(\"want %v, but got %v\", tt.want, got)","\t\t\t}","\t\t})","\t}","}"],"prefix":"utt"},"rm":{"description":"rm","body":["err := os.Remove($1)"],"prefix":"rm"},"bench":{"description":"benchmark","body":["func Benchmark$1(b *testing.B) {","\tfor i := 0; i < b.N; i++ {","\t\t$2","\t}","}"],"prefix":"bench"},"filter":{"description":"tipical filter","body":["var $1 []$2","for _, e := range $3 {","\tif $4 {","\t\t$1 = append($1, e)","\t}","}","return $1"],"prefix":"filter"},"mkdirp":{"description":"mkdir -p","body":["err := os.MkdirAll($1, os.ModePerm)"],"prefix":"mkdirp"},"fn":{"description":"function","body":["func $1 {","}"],"prefix":"fn"},"terr":{"description":"t.Errorf","body":["t.Errorf(\"want %v, but got %v\", $1, $2)"],"prefix":"terr"},"hf":{"description":"http handler func","body":["func ${1:handler}(w http.ResponseWriter, r *http.Request) {","\t$2","}"],"prefix":"hf"},"file.open":{"description":"open file","body":["${1:file}, err := os.Open(${2:path})","if err != nil {","\t${3:panic(err)}","}","defer $1.Close()"],"prefix":"file.open"},"file.create":{"description":"create file","body":["f, err := os.Create($1)","if err != nil {","\t${2:panic(err)}","}","defer f.Close()"],"prefix":"file.create"},"cd":{"description":"cd","body":["err := os.Chdir($1)"],"prefix":"cd"},"export":{"description":"export","body":["err := os.Setenv($1, $2)"],"prefix":"export"},"w":{"description":"wraps error","body":["fmt.Errorf(\"$1: %w\", err)"],"prefix":"w"},"env":{"description":"env var","body":["$1 := os.Getenv($2)"],"prefix":"env"},"append":{"description":"append to slice","body":["$1 = append($1, $2)"],"prefix":"append"}}
