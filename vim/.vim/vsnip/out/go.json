{
  "main": {
    "prefix": "main",
    "description": "main function",
    "body": [
      "package main",
      "",
      "func main() {",
      "\t$1",
      "}"
    ]
  },
  "pack": {
    "prefix": "pack",
    "description": "package",
    "body": [
      "package ${TM_DIRECTORY}"
    ]
  },
  "fn": {
    "prefix": "fn",
    "description": "function",
    "body": [
      "func $1 {",
      "\t$2",
      "}"
    ]
  },
  "ife": {
    "prefix": "ife",
    "description": "if error",
    "body": [
      "if err != nil {",
      "\t${1:return nil, err}",
      "}"
    ]
  },
  "utt": {
    "prefix": "utt",
    "description": "table driven test skelton",
    "body": [
      "func Test$1(t *testing.T) {",
      "\ttests := []struct {",
      "\t\tinput string",
      "\t\twant string",
      "\t}{",
      "\t\t{\"hoge\", \"fuga\"},",
      "\t}",
      "",
      "\tfor _, tt := range tests {",
      "\t\tt.Run(fmt.Sprintf(\"%s\", tt.input), func(t *testing.T) {",
      "\t\t\tgot := Testee(tt.input)",
      "\t\t\tif got != tt.want {",
      "\t\t\t\tt.Errorf(\"error!\")",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "}"
    ]
  },
  "ut": {
    "prefix": "ut",
    "description": "unit test",
    "body": [
      "func Test$1(t *testing.T) {",
      "\t$2",
      "}"
    ]
  },
  "open_file": {
    "prefix": [
      "file.open",
      "open.file"
    ],
    "description": "open file",
    "body": [
      "${1:file}, err := os.Open(${2:path})",
      "if err != nil {",
      "\t${3:panic(err)}",
      "}",
      "defer $1.Close()"
    ]
  },
  "create_file": {
    "prefix": [
      "file.create",
      "create.file"
    ],
    "description": "create file",
    "body": [
      "f, err := os.Create($1)",
      "if err != nil {",
      "\t${2:panic(err)}",
      "}",
      "defer func() {",
      "\tif err := f.Close(); err != nil {",
      "\t\tpanic(err)",
      "\t}",
      "}"
    ]
  },
  "fori": {
    "prefix": "fori",
    "description": "for loop",
    "body": [
      "for i:=${1:0}; i<${2:n}; ${3:i++} {",
      "\t$4",
      "}"
    ]
  },
  "fors": {
    "prefix": "fors",
    "description": "for select",
    "body": [
      "for {",
      "\tselect {",
      "\tcase $1:",
      "\t}",
      "}"
    ]
  },
  "hf": {
    "prefix": "hf",
    "description": "http handler func",
    "body": [
      "func ${1:handler}(w http.ResponseWriter, r *http.Request) {",
      "\t$2",
      "}"
    ]
  },
  "filter": {
    "prefix": "filter",
    "description": "tipical filter",
    "body": [
      "var $1 []$2",
      "for _, e := range $3 {",
      "\tif $4 {",
      "\t\t$1 = append($1, e)",
      "\t}",
      "}",
      "return $1"
    ]
  },
  "enum": {
    "prefix": "enum",
    "description": "enum",
    "body": [
      "type $1 int",
      "const (",
      "\t$3 $1 = iota",
      "\t$4",
      ")"
    ]
  },
  "st": {
    "prefix": "st",
    "description": "struct",
    "body": [
      "type $1 struct {",
      "\t$2",
      "}"
    ]
  },
  "recover": {
    "prefix": "recover",
    "description": "recover",
    "body": [
      "defer func() {",
      "\tif r := recover(); r != nil {",
      "\t\t$1",
      "\t}",
      "}()"
    ]
  },
  "mkdir": {
    "prefix": "mkdir",
    "description": "mkdir",
    "body": [
      "err := os.Mkdir($1, os.ModePerm)"
    ]
  },
  "exist": {
    "prefix": [
      "exist",
      "exists"
    ],
    "description": "check file or dir exists",
    "body": [
      "if _, err := os.Stat($1); os.IsNotExist(err) {",
      "\t$2",
      "}"
    ]
  }
}
