#!/bin/bash
set -eu
readonly SCRIPT_DIR=$(cd $(dirname $0); pwd)

DEBUG=true
# If DRY_RUN is set `echo`, commands that affect the filesystem will not
# be executed but printed to console.
DRY_RUN=
# If FORCED is set `true`, copy and symlink will overwrite existing files.
FORCED=false

function log() {
  if ! ${DEBUG}; then
    return 0
  fi

  local severity="$1"
  local message="${@:2}"
  echo "[${severity}] ${message}" >&2
}

function symlink() {
  local filename=$1
  local src="${SCRIPT_DIR}/dotfiles/${filename}"
  local dest="${HOME}/${filename}"
  ${DRY_RUN} mkdir -p $(dirname ${dest})
  if ${FORCED}; then
    log INFO "force symlink ${src} to ${dest}."
    ${DRY_RUN} ln -s -F "${src}" "${dest}"
  else
    if [[ -e "${dest}" ]]; then
      log INFO "${dest} already exists. symlink skipped."
      return 0
    fi
    log INFO "symlink ${src} to ${dest}."
    ${DRY_RUN} ln -s "${src}" "${dest}"
  fi
  echo "deployed: ${src} -> ${dest}"
}

function copy() {
  local filename=$1
  local src="${SCRIPT_DIR}/dotfiles/${filename}"
  local dest="${HOME}/${filename}"
  ${DRY_RUN} mkdir -p $(dirname ${dest})
  if ${FORCED}; then
    log INFO "force copy ${src} to ${dest}."
    ${DRY_RUN} cp "${src}" "${dest}"
  else
    if [[ -e "${dest}" ]]; then
      log INFO "${dest} already exists. copy skipped."
      return 0
    fi
    log INFO "copy ${src} to ${dest}."
    ${DRY_RUN} cp -n "${src}" "${dest}"
  fi
  echo "deployed: ${src} -> ${dest}"
}

function deploy_files() {
  while read -r filename; do
    symlink ${filename}
  done < "${SCRIPT_DIR}/symlink.conf"

  while read -r filename; do
    copy ${filename}
  done < "${SCRIPT_DIR}/copy.conf"
}

function download_file() {
  local dest_filepath="${HOME}/$1"
  local src_url=$2
  if [[ -e "${dest_filepath}" ]]; then
    log INFO "${dest_filepath} already exists. download skipped."
    return 0
  fi
  log INFO "download ${src_url} to ${dest_filepath}."
  ${DRY_RUN} curl "${src_url}" -o "${dest_filepath}"
  echo "deployed: ${src_url} -> ${dest_filepath}"
}

function clone_git_repo() {
  local dest_dirname="${HOME}/$1"
  local repo_url=$2
  if [[ -e "${dest_dirname}" ]]; then
    log INFO "${dest_dirname} already exists. clone skipped."
    return 0
  fi
  log INFO "clone ${repo_url} into ${dest_dirname}."
  ${DRY_RUN} git clone "${repo_url}" "${dest_dirname}"
  echo "deployed: ${repo_url} -> ${dest_dirname}"
}

function download_external() {
  local pid_array=()

  while read -r filename url; do
    download_file "${filename}" "${url}" &
    pid_array+=($!)
  done < "${SCRIPT_DIR}/external_files.conf"

  while read -r dirname url; do
    clone_git_repo "${dirname}" "${url}" &
    pid_array+=($!)
  done < "${SCRIPT_DIR}/external_repos.conf"

  wait ${pid_array[@]}
}

function get_last_modified_in_unix_time() {
  # FIXME: これだとsymlink自体の時間は取れないのでlockファイルを通常ファイルにしている
  local filepath="$1"
  date -r "${filepath}" +%s
}

function on_run_script_once_failed() {
  log ERROR "${script_filepath} failed."
  echo "run script: ${script_filepath} failed."
  log INFO "delete lock file ${lock_filepath}"
  ${DRY_RUN} rm -f "${lock_filepath}" || true
}

function run_script_once() {
  local script_filepath="${SCRIPT_DIR}/scripts/$1"
  local lock_filepath="${SCRIPT_DIR}/.lock/$1"

  if [[ -e "${lock_filepath}" ]] || ! ${DRY_RUN} ln -s "${script_filepath}" "${lock_filepath}" 2>/dev/null; then
    log INFO "${script_filepath} skipped."
    return 0
  fi

  trap on_run_script_once_failed ERR
  log INFO "run ${script_filepath}."
  echo "run script: ${script_filepath}."
  ${DRY_RUN} bash "${script_filepath}"
}

function run_script_on_change() {
  local script_filepath="${SCRIPT_DIR}/scripts/$1"
  local lock_filepath="${SCRIPT_DIR}/.lock/$1"

  if [[ -e "${lock_filepath}" ]]; then
    local script_timestamp="$(get_last_modified_in_unix_time ${script_filepath})"
    local lock_timestamp="$(get_last_modified_in_unix_time ${lock_filepath})"
    if [[ "${lock_timestamp}" -gt "${script_timestamp}" ]]; then
      log INFO "${script_filepath} skipped."
      return 0
    fi
  fi

  trap "log ERROR ${script_filepath} failed.; echo run script: ${script_filepath} failed." ERR
  log INFO "run ${script_filepath}."
  echo "run script: ${script_filepath}."
  ${DRY_RUN} bash "${script_filepath}"

  # FIXME: lockをtouchで作成しているのでアトミックじゃない
  ${DRY_RUN} touch "${lock_filepath}"
}

function run_scripts() {
  if [[ ! -d "${SCRIPT_DIR}/.lock" ]]; then
    mkdir "${SCRIPT_DIR}/.lock"
  fi

  while read -r filename; do
    if [[ "${filename}" =~ ^run_once ]]; then
      run_script_once "${filename}"
    elif [[ "${filename}" =~ ^run_onchange ]]; then
      run_script_on_change "${filename}"
    fi
  done < <(find "${SCRIPT_DIR}/scripts" -type f | sed 's@^.*/@@' | sort)
}

function deploy() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -d|--dry-run)
        log INFO "set dry-run option."
        DRY_RUN=echo
        ;;
      -f|--force)
        log INFO "set force option."
        FORCED=true
        ;;
      -h|--help)
        cat <<USAGE >&2
usage: $0 deploy [OPTION]
  -d  --dry-run  Show commands to be executed.
  -f --force  Force make symlink and copy dotfiles.
  -h --help Show this help and exit.
USAGE
        exit 1
        ;;
    esac
    shift
  done

  deploy_files
  download_external
  run_scripts
}

function status() {
  while read -r filename; do
    if [[ -d "${SCRIPT_DIR}/dotfiles/${filename}" ]]; then
      while read -r filepath; do
        if ! git diff --quiet "${filepath}"; then
          echo "modified from committed:" $(echo ${filepath} | sed "s@${SCRIPT_DIR}/dotfiles/@@")
        fi
      done < <(find "${SCRIPT_DIR}/dotfiles/${filename}" -type f)
    else
      if ! git diff --quiet "${SCRIPT_DIR}/dotfiles/${filename}"; then
        echo "modified from committed: ${filename}"
      fi
    fi
  done < "${SCRIPT_DIR}/symlink.conf"

  while read -r filename; do
    if ! cmp --quiet "${SCRIPT_DIR}/dotfiles/${filename}" "${HOME}/${filename}"; then
      echo "modified from original: ${filename}"
    fi
  done < "${SCRIPT_DIR}/copy.conf"

  while read -r filename; do
    if [[ "${filename}" =~ ^run && ! -e "${SCRIPT_DIR}/.lock/${filename}" ]]; then
      echo "not executed: ${filename}"
    fi
  done < <(find "${SCRIPT_DIR}/scripts" -type f | sed 's@^.*/@@')
}

function diff() {
  if [[ $# -lt 1 ]]; then
    echo 'Nothing specified.' >&2
    cat <<USAGE >&2
usage: $0 diff <filename> [OPTION]
  -u  --unified  Show unified diff.
USAGE
    exit 1
  fi

  local filename=$1
  local original="${SCRIPT_DIR}/dotfiles/${filename}"
  local deployed="${HOME}/${filename}"

  local unified=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -u|--unified)
        log INFO "set unified option."
        unified=true
        ;;
    esac
    shift
  done

  if ${unified}; then
    # FIXME: symlinkをフォローしないので差分が出てしまう
    git diff --no-index "${original}" "${deployed}"
  else
    vimdiff "${original}" "${deployed}"
  fi
}

function clear() {
  log INFO "clear lock files."
  ${DRY_RUN} rm -f "${SCRIPT_DIR}/.lock/*"
}

function add_copy() {
  local filepath="$1"
  local dir=$(dirname "${filepath}")
  ${DRY_RUN} mkdir -p "${SCRIPT_DIR}/dotfiles/${dir}"
  ${DRY_RUN} cp -a "${HOME}/${filepath}" "${SCRIPT_DIR}/dotfiles/${filepath}"
  ${DRY_RUN} echo "${filepath}" >> "${SCRIPT_DIR}/copy.conf"
}

function add_symlink() {
  local filepath="$1"
  local dir=$(dirname "${filepath}")
  ${DRY_RUN} mkdir -p "${SCRIPT_DIR}/dotfiles/${dir}"
  ${DRY_RUN} mv "${HOME}/${filepath}" "${SCRIPT_DIR}/dotfiles/${filepath}"
  ${DRY_RUN} ln -s "${SCRIPT_DIR}/dotfiles/${filepath}" "${HOME}/${filepath}"
  ${DRY_RUN} echo "${filepath}" >> "${SCRIPT_DIR}/symlink.conf"
}

function add_external_file() {
  ${DRY_RUN} echo "$1 $2" >> "${SCRIPT_DIR}/external_files.conf"
}
function add_external_git_repo() {
  ${DRY_RUN} echo "$1 $2" >> "${SCRIPT_DIR}/external_repos.conf"
}

function add() {
  local filepaths=()
  local add_fn
  local url
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -c | --copy)
        add_fn=add_copy
        ;;
      -s | --symlink)
        add_fn=add_symlink
        ;;
      -e | --external-file)
        add_fn=add_external_file
        shift
        url="$1"
        ;;
      -g | --git-repo)
        add_fn=add_external_git_repo
        shift
        url="$1"
        ;;
      *)
        filepaths+=("$1")
        ;;
    esac
    shift
  done

  if [[ -z "${add_fn}" ]]; then
    log ERROR 'specify option'
    cat <<USAGE
usage: $0 add <filename> [OPTION]
  -c  --copy  Add a file distributed as a copy.
  -s  --symlink  Add a file distributed as a symlink.
  -e  --external-file URL  Add an external file.
  -g  --git-repo URL  Add a git repository.
USAGE
    exit 1
  fi

  for filepath in "${filepaths[@]}"; do
    log INFO "add ${filepath} under dotfiles management."
    ${add_fn} "${filepath}" "${url:-}"
    ${DRY_RUN} git -C "${SCRIPT_DIR}" add "dotfiles/${filepath}"
  done
}

function usage() {
  cat <<USAGE >&2
usage: $0 SUBCOMMAND [OPTION]
  deploy  Distribute dotfiles.
  status  List modified dotfiles.
  diff  Compare file.
  clear  Clear lock file for run_once scripts.
  add  Add a file under dotfiles management.
USAGE
}

### main ###
if [[ $# -lt 1 ]]; then
  usage
  exit 1
fi
readonly SUBCOMMAND="$1"; shift
case "${SUBCOMMAND}" in
  deploy | status | diff | clear | add)
    ${SUBCOMMAND} $@
    ;;
  noop)
    :
    ;;
  -h|--help)
    usage
    exit 1
    ;;
  *)
    echo "unknown subcommand: ${SUBCOMMAND}" >&2
    usage
    exit 1
    ;;
esac
