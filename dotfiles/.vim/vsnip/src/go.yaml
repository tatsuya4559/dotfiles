main:
  prefix: main
  description: main func
  body: |
    package main

    func main() {
    	$1
    }
pack:
  prefix: pack
  description: package
  body: |
    package ${TM_DIRECTORY}

# ultisnipから移行できていない
# sonictemplate使う？
# snippet "([\w\.]+).append" "append" r
# `!p snip.rv = match.group(1)` = append(`!p snip.rv = match.group(1)`, $1)

fn:
  prefix: fn
  description: function
  body: |
    func $1 {
    	$2
    }
ife:
  prefix: ife
  description: if error
  body: |
    if err != nil {
    	${1:return nil, err}
    }
ut.table:
  prefix: ut.table
  description: table driven test skelton
  body: |
    func Test$1(t *testing.T) {
    	tests := []struct {
    		input string
    		want string
    	}{
    		{input: "hoge", want: "fuga"},
    	}

    	for _, tt := range tests {
    		got := Testee(tt.input)
    		if got != tt.want {
    			t.Errorf(error!")"
    		}
    	}
    }
ut:
  prefix: ut
  description: test function
  body: |
    func Test$1(t *testing.T) {
    	$2
    }
open.file:
  prefix: open.file
  description: open file
  body: |
    ${1:file}, err := os.Open(${2:path})
    if err != nil {
    	${3:panic(err)}
    }
    defer $1.Close()
fori:
  prefix: fori
  description: for i:=0; i<n; i++ loop
  body: |
    for i:=${1:0}; i<${2:n}; ${3:i++} {
    	$4
    }
fors:
  prefix: fors
  description: for select
  body: |
    for {
    	select {
    	case $1:
    	}
    }
http.hf:
  prefix: http.hf
  description: handler function
  body: |
    func ${1:handler}(w http.ResponseWriter, r *http.Request) {
    	$2
    }
filter:
  prefix: filter
  description: tipical filter
  body: |
    var $1 []$2
    for _, e := range $3 {
    	if $4 {
    		$1 = append($1, e)
    	}
    }
    return $1
enum:
  prefix: enum
  description: enum
  body: |
    type $1 int
    const (
    	$3 $1 = iota
    	$4
    )
